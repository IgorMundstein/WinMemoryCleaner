name: Submit to Scoop

on:
  release:
    types: [published]
  workflow_dispatch:

concurrency:
  cancel-in-progress: false
  group: submit-to-scoop-${{ github.ref }}

permissions:
  contents: read
  issues: read
  pull-requests: read

env:
  APP_NAME: WinMemoryCleaner
  ASSET_FILE: WinMemoryCleaner.exe
  FIXED_DESCRIPTION: Portable RAM cleaner using native Windows APIs to release memory.
  FORK_REPO: ${{ github.repository_owner }}/Scoop
  LICENSE_ID: GPL-3.0-or-later
  LICENSE_URL_PATH: blob/main/LICENSE
  MANIFEST_NAME: winmemorycleaner
  NOTES_TEXT: Requires administrator privileges (UAC prompt). Requires .NET Framework 4.x runtime.
  UPSTREAM_BRANCH: master
  UPSTREAM_REPO: ScoopInstaller/Main

jobs:
  submit:
    runs-on: windows-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve version
        env:
          GH_TOKEN: ${{ github.token }}
        id: version
        run: |
          if ("${{ github.event_name }}" -eq "release") {
            $tag = "${{ github.event.release.tag_name }}"
          } else {
            $latest = gh release list --limit 1 | Select-Object -First 1
            if (-not $latest) { Write-Error "No releases found."; exit 1 }
            $tag = ($latest -split '\s+')[0]
          }
          if ([string]::IsNullOrWhiteSpace($tag)) { Write-Error "Tag empty"; exit 1 }
          "tag=$tag"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Check existing upstream PR
        env:
          GH_TOKEN: ${{ github.token }}
        id: existing_pr
        run: |
          $branch = "update/${{ env.MANIFEST_NAME }}-${{ steps.version.outputs.version }}"
          $encodedHead = [System.Uri]::EscapeDataString("${{ github.repository_owner }}:$branch")
          $url = "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/pulls?state=open&head=$encodedHead"
          try { $resp = gh api -H "Accept: application/vnd.github+json" $url 2>$null | ConvertFrom-Json } catch { $resp = @() }
          if ($resp -and $resp.Count -gt 0) { "pr_exists=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append } else { "pr_exists=no" | Out-File -FilePath $env:GITHUB_OUTPUT -Append }
          "branch=$branch" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Check upstream manifest
        id: upstream
        if: steps.existing_pr.outputs.pr_exists == 'no'
        run: |
          $url = "https://raw.githubusercontent.com/${{ env.UPSTREAM_REPO }}/${{ env.UPSTREAM_BRANCH }}/bucket/${{ env.MANIFEST_NAME }}.json"
          try {
            $data = Invoke-RestMethod -Uri $url -Method Get -TimeoutSec 15 -ErrorAction Stop
            if ($data.version -eq "${{ steps.version.outputs.version }}") {
              "skip=yes"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "update=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            } else {
              "skip=no"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "update=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            }
          } catch {
            "skip=no"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "update=no" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
        shell: pwsh

      - name: Plan
        id: plan
        run: |
          $mode = "create"
          if ("${{ steps.existing_pr.outputs.pr_exists }}" -eq "yes") { $mode = "update" }
          elseif ("${{ steps.upstream.outputs.skip }}" -eq "yes") { $mode = "none" }
          "mode=$mode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Stop duplicate PR
        if: steps.plan.outputs.mode == 'update'
        run: echo "Duplicate PR exists; updating."

      - name: Stop already current
        if: steps.plan.outputs.mode == 'none'
        run: echo "Upstream already current; nothing to do."

      - name: Probe asset
        id: asset
        if: steps.plan.outputs.mode != 'none'
        run: |
          $url = "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/${{ env.ASSET_FILE }}"
          try {
            $r = Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing -TimeoutSec 20 -ErrorAction Stop
            if ($r.StatusCode -lt 200 -or $r.StatusCode -ge 400) { throw "Bad status $($r.StatusCode)" }
          } catch {
            Write-Error "Asset not reachable: $url"
            exit 1
          }
          "asset_url=$url" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Download and hash
        id: hash
        if: steps.plan.outputs.mode != 'none'
        run: |
          $url  = "${{ steps.asset.outputs.asset_url }}"
          $file = "${{ env.ASSET_FILE }}"
          Invoke-WebRequest -Uri $url -OutFile $file -UseBasicParsing -ErrorAction Stop -TimeoutSec 180
          if ((Get-Item $file).Length -le 0) { Write-Error "Empty asset"; exit 1 }
          $sha = (Get-FileHash -Path $file -Algorithm SHA256).Hash.ToLower()
          "sha256=$sha" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Generate manifest
        id: manifest
        if: steps.plan.outputs.mode != 'none'
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $tag     = "${{ steps.version.outputs.tag }}"
          $hash    = "${{ steps.hash.outputs.sha256 }}"
          $owner   = "${{ github.repository_owner }}"
          $repo    = "${{ github.event.repository.name }}"
          if (-not $repo) { $repo = ("${{ github.repository }}" -split "/")[1] }
          $licenseUrl = "https://github.com/$owner/$repo/${{ env.LICENSE_URL_PATH }}"
          $notes = @(
            "Requires administrator privileges (UAC prompt).",
            "Requires .NET Framework 4.x runtime."
          )
          $shortcutInner = ,@("${{ env.APP_NAME }}.exe","${{ env.APP_NAME }}")
          $shortcuts     = @($shortcutInner)
          $obj = [ordered]@{
            architecture = @{
              "32bit" = @{
                url  = "https://github.com/$owner/$repo/releases/download/$tag/${{ env.ASSET_FILE }}"
                hash = $hash
              }
              "64bit" = @{
                url  = "https://github.com/$owner/$repo/releases/download/$tag/${{ env.ASSET_FILE }}"
                hash = $hash
              }
            }
            autoupdate  = @{
              architecture = @{
                "32bit" = @{ url = "https://github.com/$owner/$repo/releases/download/`$version/${{ env.ASSET_FILE }}" }
                "64bit" = @{ url = "https://github.com/$owner/$repo/releases/download/`$version/${{ env.ASSET_FILE }}" }
              }
            }
            bin         = "${{ env.APP_NAME }}.exe"
            checkver    = "github"
            description = "${{ env.FIXED_DESCRIPTION }}"
            homepage    = "https://github.com/$owner/$repo"
            license     = @{ identifier = "${{ env.LICENSE_ID }}"; url = $licenseUrl }
            notes       = $notes
            shortcuts   = $shortcuts
            version     = $version
          }
          if ($obj.shortcuts -is [string[]]) { $obj.shortcuts = @(@($obj.shortcuts)) }
          New-Item -ItemType Directory -Force -Path manifest-out | Out-Null
          $path = "manifest-out/${{ env.MANIFEST_NAME }}.json"
          ($obj | ConvertTo-Json -Depth 8) | Set-Content -LiteralPath $path -Encoding UTF8
          "path=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Validate manifest
        if: steps.plan.outputs.mode != 'none'
        run: |
          $p = "${{ steps.manifest.outputs.path }}"
          $j = (Get-Content $p -Raw) | ConvertFrom-Json
          $reasons = @()
          foreach ($f in 'architecture','autoupdate','bin','checkver','description','homepage','license','notes','shortcuts','version') {
            if (-not $j.PSObject.Properties.Name.Contains($f)) { $reasons += "Missing field: $f" }
          }
          if (-not $j.license) { $reasons += "Missing license object" }
          elseif ($j.license.identifier -ne "${{ env.LICENSE_ID }}") { $reasons += "license.identifier must be ${{ env.LICENSE_ID }}" }
          if (-not $j.license.url -or $j.license.url -notmatch '/LICENSE$') { $reasons += "license.url must end with /LICENSE" }
          if ($j.notes -isnot [System.Array] -or $j.notes.Count -lt 2) { $reasons += "notes must be an array with at least 2 entries" }
          if (-not $j.architecture.'32bit' -or -not $j.architecture.'64bit') { $reasons += "architecture must include 32bit and 64bit" }
          foreach ($a in '32bit','64bit') {
            if (-not $j.architecture.$a.url) { $reasons += "architecture.$a.url missing" }
            if (-not $j.architecture.$a.hash) { $reasons += "architecture.$a.hash missing" }
          }
          if ($j.checkver -ne 'github') { $reasons += "checkver must be 'github'" }
          if (-not $j.autoupdate.architecture.'32bit'.url -or -not $j.autoupdate.architecture.'64bit'.url) { $reasons += "autoupdate.architecture must define 32bit and 64bit urls" }
          if ($j.autoupdate.architecture.'32bit'.url -notmatch '\$version' -or $j.autoupdate.architecture.'64bit'.url -notmatch '\$version') { $reasons += "autoupdate urls must contain $version" }
          if ($j.shortcuts.Count -lt 1 -or ($j.shortcuts[0] -isnot [System.Array]) -or $j.shortcuts[0].Count -ne 2) { $reasons += "shortcuts must be an array of [exe, name]" }
          if ($reasons.Count) {
            $reasons | ForEach-Object { Write-Error $_ }
            exit 1
          }
        shell: pwsh

      - name: Find or create related issue
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        id: issue
        if: steps.plan.outputs.mode != 'none'
        run: |
          if (-not $env:GH_TOKEN -or $env:GH_TOKEN.Length -eq 0) { $env:GH_TOKEN = "${{ github.token }}" }
          $manifest  = "${{ env.MANIFEST_NAME }}"
          $app       = "${{ env.APP_NAME }}"
          $repoUp    = "${{ env.UPSTREAM_REPO }}"
          $owner     = "${{ github.repository_owner }}"
          $repoSelf  = "${{ github.event.repository.name }}"
          if (-not $repoSelf) { $repoSelf = ("${{ github.repository }}" -split "/")[1] }
          function Pick-Issue {
            param($term)
            $data = gh issue list --repo $repoUp --state open --search "$term in:title" --json number,title --limit 20 2>$null | ConvertFrom-Json
            if ($data) {
              $exact = $data | Where-Object { $_.title -match [regex]::Escape($manifest) }
              if ($exact) { return $exact[0].number }
              return $data[0].number
            }
            return ""
          }
          $issueNum = Pick-Issue $manifest
          if (-not $issueNum) { $issueNum = Pick-Issue $app }
          $homepage = "https://github.com/$owner/$repoSelf"
          $download = "https://github.com/$owner/$repoSelf/releases/download/${{ steps.version.outputs.tag }}/${{ env.ASSET_FILE }}"
          $body = @(
            "Package request: $app ${{ steps.version.outputs.version }}",
            "",
            "Homepage: $homepage",
            "Download: $download",
            "License: ${{ env.LICENSE_ID }}",
            "Notes: ${{ env.NOTES_TEXT }}"
          ) -join "`n"
          if ($issueNum) {
            try {
              $current = gh issue view --repo $repoUp $issueNum --json body --jq .body 2>$null
            } catch { $current = "" }
            if (-not $current -or $current.Trim() -ne $body.Trim()) {
              try { gh issue edit --repo $repoUp $issueNum --body "$body" 2>$null } catch { }
            }
          } else {
            $created = ""
            try { $created = gh issue create --repo $repoUp --title "Package Request: $app" --body "$body" --json number --jq .number 2>$null } catch { }
            if (-not $created) {
              try {
                $fallback = gh issue create --repo $repoUp --title "Package Request: $app" --body "$body" 2>&1
                if ($fallback -match "/issues/(\d+)") { $created = $Matches[1] }
              } catch { }
            }
            $issueNum = $created
          }
          if ($issueNum) {
            "issue_line=Closes #$issueNum" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "issue_line=No related issue (new manifest)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
        shell: pwsh

      - name: Compose PR body
        id: prbody
        if: steps.plan.outputs.mode == 'create'
        run: |
          $version   = "${{ steps.version.outputs.version }}"
          $issueLine = "${{ steps.issue.outputs.issue_line }}"
          $body = @(
            "Adds the initial Scoop manifest for WinMemoryCleaner $version."
            ""
            "${{ env.FIXED_DESCRIPTION }}"
            ""
            $issueLine
            ""
            '- [x] Use conventional PR title: `<manifest-name[@version]|chore>: <general summary of the pull request>`'
            '- [x] I have read the [Contributing Guide](https://github.com/ScoopInstaller/.github/blob/main/.github/CONTRIBUTING.md)'
          ) -join "`n"
          Set-Content pr_body.txt -Value $body -Encoding UTF8
          "file=pr_body.txt" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "title=${{ env.MANIFEST_NAME }}: Add version $version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: pwsh

      - name: Create PR
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        if: steps.plan.outputs.mode == 'create'
        run: |
          if (-not $env:GH_TOKEN -or $env:GH_TOKEN.Length -eq 0) { $env:GH_TOKEN = "${{ github.token }}" }
          $branch   = "${{ steps.existing_pr.outputs.branch }}"
          $version  = "${{ steps.version.outputs.version }}"
          $title    = "${{ steps.prbody.outputs.title }}"
          $bodyFile = "../${{ steps.prbody.outputs.file }}"
          $commitMsg = "${{ env.MANIFEST_NAME }}: Add version $version"
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git clone "https://x-access-token:${{ env.GH_TOKEN }}@github.com/${{ env.FORK_REPO }}.git" fork --depth=1
          Set-Location fork
          git remote add upstream "https://github.com/${{ env.UPSTREAM_REPO }}.git"
          git fetch upstream "${{ env.UPSTREAM_BRANCH }}" --depth=1
          if (git ls-remote --heads origin $branch) { git push origin :$branch }
          git checkout -b $branch "upstream/${{ env.UPSTREAM_BRANCH }}"
          Copy-Item "../${{ steps.manifest.outputs.path }}" "bucket/${{ env.MANIFEST_NAME }}.json" -Force
          git add "bucket/${{ env.MANIFEST_NAME }}.json"
          if (git diff --cached --quiet) {
            echo "No changes to commit."
          } else {
            git commit -m "$commitMsg"
            git push origin $branch
          }
          $out = gh pr create --repo "${{ env.UPSTREAM_REPO }}" --head "${{ github.repository_owner }}:$branch" --base "${{ env.UPSTREAM_BRANCH }}" --title "$title" --body-file "$bodyFile" 2>&1
          if ($LASTEXITCODE -ne 0 -and $out -notmatch 'already exists') {
            Write-Host $out
            exit 1
          }
        shell: pwsh

      - name: Update existing PR branch
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        if: steps.plan.outputs.mode == 'update'
        run: |
          if (-not $env:GH_TOKEN -or $env:GH_TOKEN.Length -eq 0) { $env:GH_TOKEN = "${{ github.token }}" }
          $branch   = "${{ steps.existing_pr.outputs.branch }}"
          $version  = "${{ steps.version.outputs.version }}"
          $commitMsg = "${{ env.MANIFEST_NAME }}: Update to version $version"
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git clone "https://x-access-token:${{ env.GH_TOKEN }}@github.com/${{ env.FORK_REPO }}.git" fork --depth=1
          Set-Location fork
          git fetch origin "${branch}:${branch}" --force
          git checkout "${branch}"
          Copy-Item "../${{ steps.manifest.outputs.path }}" "bucket/${{ env.MANIFEST_NAME }}.json" -Force
          git add "bucket/${{ env.MANIFEST_NAME }}.json"
          if (git diff --cached --quiet) {
            echo "No changes to commit."
          } else {
            git commit -m "$commitMsg"
            git push origin "${branch}"
          }
        shell: pwsh

      - name: Finish early note
        if: steps.plan.outputs.mode == 'none'
        run: echo "Finished (duplicate PR or upstream already current)."
