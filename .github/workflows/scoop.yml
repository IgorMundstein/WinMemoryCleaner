name: Submit to Scoop

on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write

env:
  FORK_REPO: ${{ github.repository_owner }}/Scoop
  UPSTREAM_REPO: ScoopInstaller/Main
  APP_NAME: WinMemoryCleaner
  MANIFEST_NAME: winmemorycleaner

jobs:
  submit:
    name: Submit to Scoop
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest release info
        id: get_release
        uses: actions/github-script@v7
        with:
          script: |
            const { data: release } = await github.rest.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const tag = release.tag_name;
            const version = tag.startsWith('v') ? tag.substring(1) : tag;
            core.setOutput('tag', tag);
            core.setOutput('version', version);

      - name: Check if manifest already exists
        id: check_scoop
        shell: pwsh
        run: |
          $manifestUrl = "https://raw.githubusercontent.com/${{ env.UPSTREAM_REPO }}/master/bucket/${{ env.MANIFEST_NAME }}.json"
          try {
            $response = Invoke-RestMethod -Uri $manifestUrl -Method Get
            if ($response.version -eq "${{ steps.get_release.outputs.version }}") {
              Write-Host "::notice::Version ${{ steps.get_release.outputs.version }} already exists in Scoop. Skipping."
              echo "skip=true" >> $env:GITHUB_OUTPUT
            } else {
              echo "skip=false" >> $env:GITHUB_OUTPUT
            }
          }
          catch {
            Write-Host "::notice::Manifest not found in Scoop. Proceeding with submission."
            echo "skip=false" >> $env:GITHUB_OUTPUT
          }

      - name: Fetch repository metadata
        if: steps.check_scoop.outputs.skip == 'false'
        id: metadata
        uses: actions/github-script@v7
        with:
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            core.setOutput('desc', repo.description?.trim() || 'A utility to clean system memory.');
            core.setOutput('homepage', repo.homepage || repo.html_url);

      - name: Prepare ZIP asset and calculate checksum
        if: steps.check_scoop.outputs.skip == 'false'
        id: prepare_zip
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $ErrorActionPreference = "Stop"
          $repo = "${{ github.repository }}"
          $tag = "${{ steps.get_release.outputs.tag }}"
          $app = "${{ env.APP_NAME }}"
          $dist = "dist"
          New-Item -ItemType Directory -Path $dist -Force | Out-Null

          # Inspect release assets
          $releaseJson = gh api "repos/$repo/releases/tags/$tag"
          $release = $releaseJson | ConvertFrom-Json
          $hasZip = $false
          $hasExe = $false
          foreach ($a in $release.assets) {
            if ($a.name -eq "$app.zip") { $hasZip = $true }
            if ($a.name -eq "$app.exe") { $hasExe = $true }
          }

          $zipPath = Join-Path $dist "$app.zip"

          if (-not $hasZip) {
            if (-not $hasExe) {
              Write-Error "Release $tag does not contain $app.exe; cannot package ZIP."
              exit 1
            }

            # Download exe
            gh release download $tag --repo $repo --pattern "$app.exe" --dir $dist --clobber

            # Collect files to include in ZIP
            $paths = @()
            $paths += (Join-Path $dist "$app.exe")
            if (Test-Path "LICENSE") { Copy-Item "LICENSE" $dist -Force; $paths += (Join-Path $dist "LICENSE") }
            if (Test-Path "LICENSE.txt") { Copy-Item "LICENSE.txt" $dist -Force; $paths += (Join-Path $dist "LICENSE.txt") }
            if (Test-Path "README.md") { Copy-Item "README.md" $dist -Force; $paths += (Join-Path $dist "README.md") }
            if (Test-Path "README.txt") { Copy-Item "README.txt" $dist -Force; $paths += (Join-Path $dist "README.txt") }
            if (Test-Path "CHANGELOG.md") { Copy-Item "CHANGELOG.md" $dist -Force; $paths += (Join-Path $dist "CHANGELOG.md") }
            if (Test-Path "CHANGELOG.txt") { Copy-Item "CHANGELOG.txt" $dist -Force; $paths += (Join-Path $dist "CHANGELOG.txt") }
            if (Test-Path "WinMemoryCleaner.ico") { Copy-Item "WinMemoryCleaner.ico" $dist -Force; $paths += (Join-Path $dist "WinMemoryCleaner.ico") }
            if (Test-Path "icon.ico") { Copy-Item "icon.ico" $dist -Force; $paths += (Join-Path $dist "icon.ico") }

            Compress-Archive -Path $paths -DestinationPath $zipPath -Force

            # Upload ZIP to the release
            gh release upload $tag $zipPath --repo $repo --clobber
          } else {
            # Download existing ZIP so we can hash it
            gh release download $tag --repo $repo --pattern "$app.zip" --dir $dist --clobber
          }

          $sha256 = (Get-FileHash -Path $zipPath -Algorithm SHA256).Hash.ToLower()
          echo "sha256=$sha256" >> $env:GITHUB_OUTPUT

      - name: Create Scoop Manifest File
        if: steps.check_scoop.outputs.skip == 'false'
        id: create_manifest
        shell: pwsh
        run: |
          $manifestDir = "scoop-manifest"
          New-Item -ItemType Directory -Path $manifestDir -Force | Out-Null
          $manifestContent = @"
          {
              "version": "${{ steps.get_release.outputs.version }}",
              "description": "${{ steps.metadata.outputs.desc }}",
              "homepage": "${{ steps.metadata.outputs.homepage }}",
              "license": "GPL-3.0-only",
              "url": "https://github.com/${{ github.repository }}/releases/download/${{ steps.get_release.outputs.tag }}/${{ env.APP_NAME }}.zip",
              "hash": "${{ steps.prepare_zip.outputs.sha256 }}",
              "bin": "${{ env.APP_NAME }}.exe",
              "shortcuts": [
                  [
                      "${{ env.APP_NAME }}.exe",
                      "${{ env.APP_NAME }}"
                  ]
              ],
              "checkver": {
                  "github": "${{ github.repository }}"
              },
              "autoupdate": {
                  "url": "https://github.com/${{ github.repository }}/releases/download/`$version/${{ env.APP_NAME }}.zip"
              }
          }
          "@
          $manifestFile = "$manifestDir/${{ env.MANIFEST_NAME }}.json"
          $manifestContent | Out-File -FilePath $manifestFile -Encoding UTF8
          echo "manifest_path=$manifestFile" >> $env:GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check_scoop.outputs.skip == 'false'
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        shell: pwsh
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git clone "https://x-access-token:${{ env.GH_TOKEN }}@github.com/${{ env.FORK_REPO }}.git" scoop-fork
          cd scoop-fork
          git remote add upstream "https://github.com/${{ env.UPSTREAM_REPO }}.git"
          git fetch upstream master --depth=1
          $version = "${{ steps.get_release.outputs.version }}"
          $branchName = "update/${{ env.MANIFEST_NAME }}-$version"
          git checkout -b $branchName upstream/master
          $manifestFile = "${{ steps.create_manifest.outputs.manifest_path }}"
          cp ../$manifestFile "bucket/${{ env.MANIFEST_NAME }}.json"
          git add .
          git commit -m "${{ env.MANIFEST_NAME }}: Update to $version" || echo "No changes to commit"
          git push --force origin $branchName
          $prOutput = gh pr create `
            --repo "${{ env.UPSTREAM_REPO }}" `
            --head "${{ github.repository_owner }}:$branchName" `
            --base master `
            --title "${{ env.MANIFEST_NAME }}: Update to $version" `
            --body "Automated submission for ${{ env.APP_NAME }} version $version." 2>&1
          if ($LASTEXITCODE -ne 0) {
            if ($prOutput -like "*a pull request for branch*already exists*") {
              Write-Host "::notice::A pull request for this version already exists. Skipping."
              exit 0
            } else {
              Write-Host "::error::Failed to create pull request: $prOutput"
              exit 1
            }
          } else {
            Write-Host "::notice::Pull request created successfully."
            Write-Host $prOutput
          }
