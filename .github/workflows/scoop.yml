name: Submit to Scoop

on:
  release:
    types: [published]
  workflow_dispatch:

concurrency:
  group: submit-to-scoop-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  pull-requests: read
  issues: read

env:
  UPSTREAM_REPO: ScoopInstaller/Main
  UPSTREAM_BRANCH: master
  FORK_REPO: ${{ github.repository_owner }}/Scoop
  APP_NAME: WinMemoryCleaner
  MANIFEST_NAME: winmemorycleaner
  LICENSE_ID: GPL-3.0-or-later
  ASSET_FILE: WinMemoryCleaner.exe
  FIXED_DESCRIPTION: Portable RAM cleaner using native Windows features to optimize memory.
  NOTES_TEXT: WinMemoryCleaner requires administrator privileges to run and may prompt for UAC elevation.

jobs:
  submit:
    runs-on: windows-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve version
        id: version
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if ("${{ github.event_name }}" -eq "release") {
            $tag = "${{ github.event.release.tag_name }}"
          } else {
            $latest = gh release list --limit 1 | Select-Object -First 1
            if (-not $latest) { Write-Error "No releases found."; exit 1 }
            $tag = ($latest -split '\s+')[0]
          }
          if ([string]::IsNullOrWhiteSpace($tag)) { Write-Error "Tag empty"; exit 1 }
          "tag=$tag"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Check existing upstream PR
        id: existing_pr
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $branch = "update/${{ env.MANIFEST_NAME }}-${{ steps.version.outputs.version }}"
          $encodedHead = [System.Uri]::EscapeDataString("${{ github.repository_owner }}:$branch")
          $url = "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/pulls?state=open&head=$encodedHead"
          try { $resp = gh api -H "Accept: application/vnd.github+json" $url 2>$null | ConvertFrom-Json } catch { $resp = @() }
          if ($resp -and $resp.Count -gt 0) {
            "pr_exists=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "pr_exists=no"  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
          "branch=$branch" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Check upstream manifest
        if: steps.existing_pr.outputs.pr_exists == 'no'
        id: upstream
        shell: pwsh
        run: |
          $url = "https://raw.githubusercontent.com/${{ env.UPSTREAM_REPO }}/${{ env.UPSTREAM_BRANCH }}/bucket/${{ env.MANIFEST_NAME }}.json"
          try {
            $data = Invoke-RestMethod -Uri $url -Method Get -TimeoutSec 15 -ErrorAction Stop
            if ($data.version -eq "${{ steps.version.outputs.version }}") {
              "skip=yes"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "update=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            } else {
              "skip=no"    | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "update=yes" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            }
          } catch {
            "skip=no"   | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "update=no" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Stop duplicate PR
        if: steps.existing_pr.outputs.pr_exists == 'yes'
        run: echo "Duplicate PR exists; stopping."

      - name: Stop already current
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'yes'
        run: echo "Upstream already current; nothing to do."

      - name: Probe asset
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        id: asset
        shell: pwsh
        run: |
          $url = "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/${{ env.ASSET_FILE }}"
          try {
            $r = Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing -TimeoutSec 20 -ErrorAction Stop
            if ($r.StatusCode -lt 200 -or $r.StatusCode -ge 400) { throw "Bad status $($r.StatusCode)" }
          } catch {
            Write-Error "Asset not reachable: $url"
            exit 1
          }
          "asset_url=$url" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Download and hash
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        id: hash
        shell: pwsh
        run: |
          $url  = "${{ steps.asset.outputs.asset_url }}"
          $file = "${{ env.ASSET_FILE }}"
          Invoke-WebRequest -Uri $url -OutFile $file -UseBasicParsing -ErrorAction Stop -TimeoutSec 180
          if ((Get-Item $file).Length -le 0) { Write-Error "Empty asset"; exit 1 }
          $sha = (Get-FileHash -Path $file -Algorithm SHA256).Hash.ToLower()
          "sha256=$sha" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate manifest
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        id: manifest
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $tag     = "${{ steps.version.outputs.tag }}"
          $hash    = "${{ steps.hash.outputs.sha256 }}"
          $owner   = "${{ github.repository_owner }}"
          $repo    = "${{ github.event.repository.name }}"
          if (-not $repo) { $repo = ("${{ github.repository }}" -split "/")[1] }
          $shortcutInner = ,@("${{ env.APP_NAME }}.exe","${{ env.APP_NAME }}")
          $shortcuts     = @($shortcutInner)
          $obj = [ordered]@{
            version     = $version
            description = "${{ env.FIXED_DESCRIPTION }}"
            homepage    = "https://github.com/$owner/$repo"
            license     = "${{ env.LICENSE_ID }}"
            notes       = "${{ env.NOTES_TEXT }}"
            url         = "https://github.com/$owner/$repo/releases/download/$tag/${{ env.ASSET_FILE }}"
            hash        = $hash
            bin         = "${{ env.APP_NAME }}.exe"
            shortcuts   = $shortcuts
            checkver    = "github"
            autoupdate  = @{
              url = "https://github.com/$owner/$repo/releases/download/`$version/${{ env.ASSET_FILE }}"
            }
          }
          if ($obj.shortcuts -is [string[]]) { $obj.shortcuts = @(@($obj.shortcuts)) }
          New-Item -Type Directory -Force -Path manifest-out | Out-Null
          $path = "manifest-out/${{ env.MANIFEST_NAME }}.json"
          ($obj | ConvertTo-Json -Depth 8) | Set-Content -LiteralPath $path -Encoding UTF8
          "path=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Validate manifest
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        shell: pwsh
        run: |
          $p = "${{ steps.manifest.outputs.path }}"
          $j = (Get-Content $p -Raw) | ConvertFrom-Json
          $ok = $true
          foreach ($f in 'version','url','hash','bin','shortcuts','checkver','autoupdate','license','notes') {
            if (-not $j.PSObject.Properties.Name.Contains($f)) { $ok = $false }
          }
          if ($j.license -ne "${{ env.LICENSE_ID }}") { $ok = $false }
          if ($j.checkver -ne 'github') { $ok = $false }
          if (-not $j.autoupdate.url.Contains('$version')) { $ok = $false }
          if ($j.shortcuts.Count -lt 1 -or ($j.shortcuts[0] -isnot [System.Array]) -or $j.shortcuts[0].Count -ne 2) { $ok = $false }
          if (-not $ok) { Write-Error "Validation failed"; exit 1 }

      - name: Find related issue
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        id: issue
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $manifest  = "${{ env.MANIFEST_NAME }}"
          $app       = "${{ env.APP_NAME }}"
          $repo      = "${{ env.UPSTREAM_REPO }}"
          function Pick-Issue {
            param($term)
            $data = gh issue list --repo $repo --state open --search "$term in:title" --json number,title --limit 20 2>$null | ConvertFrom-Json
            if ($data) {
              $exact = $data | Where-Object { $_.title -match [regex]::Escape($manifest) }
              if ($exact) { return $exact[0].number }
              return $data[0].number
            }
            return ""
          }
          $issueNum = Pick-Issue $manifest
          if (-not $issueNum) { $issueNum = Pick-Issue $app }
          if ($issueNum) {
            "issue_line=Closes #$issueNum" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "issue_line=No related issue (new manifest)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Compose PR body
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        id: prbody
        shell: pwsh
        run: |
          $version   = "${{ steps.version.outputs.version }}"
          $issueLine = "${{ steps.issue.outputs.issue_line }}"
          $body = @(
            "Adds the initial Scoop manifest for WinMemoryCleaner $version."
            ""
            "Portable RAM cleaner using native Windows features to optimize memory."
            ""
            $issueLine
            ""
            '- [x] Use conventional PR title: `<manifest-name[@version]|chore>: <general summary of the pull request>`'
            '- [x] I have read the [Contributing Guide](https://github.com/ScoopInstaller/.github/blob/main/.github/CONTRIBUTING.md)'
          ) -join "`n"
          Set-Content pr_body.txt -Value $body -Encoding UTF8
          "file=pr_body.txt" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "title=${{ env.MANIFEST_NAME }}: Add version $version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Create PR
        if: steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'no'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          if (-not $env:GH_TOKEN -or $env:GH_TOKEN.Length -eq 0) { $env:GH_TOKEN = "${{ github.token }}" }
          $branch   = "${{ steps.existing_pr.outputs.branch }}"
          $version  = "${{ steps.version.outputs.version }}"
          $title    = "${{ steps.prbody.outputs.title }}"
          $bodyFile = "../${{ steps.prbody.outputs.file }}"
          $commitMsg = "${{ env.MANIFEST_NAME }}: Add version $version"
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git clone "https://x-access-token:${{ env.GH_TOKEN }}@github.com/${{ env.FORK_REPO }}.git" fork --depth=1
          Set-Location fork
          git remote add upstream "https://github.com/${{ env.UPSTREAM_REPO }}.git"
          git fetch upstream "${{ env.UPSTREAM_BRANCH }}" --depth=1
          if (git ls-remote --heads origin $branch) { git push origin :$branch }
          git checkout -b $branch "upstream/${{ env.UPSTREAM_BRANCH }}"
          Copy-Item "../${{ steps.manifest.outputs.path }}" "bucket/${{ env.MANIFEST_NAME }}.json" -Force
          git add "bucket/${{ env.MANIFEST_NAME }}.json"
          if (git diff --cached --quiet) {
            echo "No changes to commit."
          } else {
            git commit -m "$commitMsg"
            git push origin $branch
          }
          $out = gh pr create --repo "${{ env.UPSTREAM_REPO }}" --head "${{ github.repository_owner }}:$branch" --base "${{ env.UPSTREAM_BRANCH }}" --title "$title" --body-file "$bodyFile" 2>&1
          if ($LASTEXITCODE -ne 0 -and $out -notmatch 'already exists') {
            Write-Host $out
            exit 1
          }

      - name: Finish early note
        if: steps.existing_pr.outputs.pr_exists == 'yes' || (steps.existing_pr.outputs.pr_exists == 'no' && steps.upstream.outputs.skip == 'yes')
        run: echo "Finished (duplicate PR or upstream already current)."
