name: Verify and Test Packages

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'
  release:
    types: [published]

jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      release_version: ${{ steps.get_version.outputs.RELEASE_VERSION }}
      cache-key: ${{ steps.cache_check.outputs.cache-primary-key }}
      cache-hit: ${{ steps.cache_restore.outputs.cache-hit }}
    steps:
      - name: "â³ Add grace period after release publication"
        if: github.event_name == 'release'
        run: sleep 14400

      - name: "ðŸ”½ Checkout Repository"
        uses: actions/checkout@v4

      - name: "ðŸ·ï¸ Get Latest Release Version"
        id: get_version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          latest_tag=$(gh release view --json tagName --jq .tagName)
          if [ -z "$latest_tag" ]; then
            echo "No releases found. Halting workflow."
            exit 1
          fi
          version="$latest_tag"
          echo "RELEASE_VERSION=$version" >> "$GITHUB_OUTPUT"
          echo "Checking for version: $version"

      - name: "ðŸ—„ï¸ Set cache key"
        id: cache_check
        run: |
          echo "cache-primary-key=verification-flag-v${{ steps.get_version.outputs.RELEASE_VERSION }}" >> $GITHUB_OUTPUT

      - name: "ðŸ—„ï¸ Restore Publication Success Cache"
        id: cache_restore
        uses: actions/cache/restore@v4
        with:
          path: ./.cache
          key: verification-flag-v${{ steps.get_version.outputs.RELEASE_VERSION }}

  choco:
    needs: setup
    if: needs.setup.outputs.cache-hit != 'true'
    runs-on: windows-latest
    timeout-minutes: 15
    outputs:
      published: ${{ steps.choco.outputs.published }}
      e2e: ${{ steps.choco.outputs.e2e_result }}
    steps:
      - name: "ðŸ« Chocolatey Verify and Test"
        id: choco
        shell: pwsh
        env:
          RELEASE_VERSION: ${{ needs.setup.outputs.release_version }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = "$env:RELEASE_VERSION"
          $packageName = "winmemorycleaner"
          $e2e_result = "fail"
          $published = "false"

          function Set-Outputs {
            param($Published, $E2E)
            echo "published=$Published" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            echo "e2e_result=$E2E" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

          Write-Host "===[Chocolatey] Checking $packageName version $version==="
          try {
            $choco_output = choco search $packageName --exact --all-versions -r
            Write-Host "Chocolatey search output:`n$choco_output"
            if ($choco_output -match "\b$([regex]::Escape($version))\b") {
              Write-Host "[Chocolatey] âœ… Version found."
              $published = "true"

              Write-Host("[Chocolatey] Installing package...")
              choco install $packageName --version $version -y --no-progress

              $chocoRoot = $env:ChocolateyInstall
              if (-not $chocoRoot) { $chocoRoot = "C:\ProgramData\chocolatey" }
              $exePath = Get-ChildItem -Path (Join-Path $chocoRoot "lib\$packageName") -Recurse -Filter "WinMemoryCleaner.exe" -File -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName -First 1
              if (-not $exePath) {
                $cmd = Get-Command WinMemoryCleaner.exe -ErrorAction SilentlyContinue
                if ($cmd -and (Test-Path $cmd.Source)) {
                  $exePath = $cmd.Source
                }
              }

              if (-not $exePath) {
                Write-Host "[Chocolatey] âŒ WinMemoryCleaner.exe not found after install"
                $e2e_result = "fail"
                Set-Outputs -Published $published -E2E $e2e_result
                exit 1
              }

              Write-Host "[Chocolatey] Found executable: $exePath"

              $verInfo = (Get-Item $exePath).VersionInfo
              $fileVersion = $verInfo.ProductVersion
              if ([string]::IsNullOrWhiteSpace($fileVersion)) { $fileVersion = $verInfo.FileVersion }
              $expectedRegex = '^' + [regex]::Escape($version) + '(\.0)?$'
              Write-Host "[Chocolatey] Installed file version: $fileVersion"
              if ($fileVersion -match $expectedRegex) {
                $e2e_result = "success"
                Write-Host "[Chocolatey] âœ… E2E Test successful (version matches)."
              } else {
                Write-Host "[Chocolatey] âŒ Version mismatch. Expected $version, got $fileVersion"
                $e2e_result = "fail"
                Set-Outputs -Published $published -E2E $e2e_result
                exit 1
              }
            } else {
              Write-Host "[Chocolatey] âŒ Version not found."
              $published = "false"
              $e2e_result = "skipped"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }
          } catch {
            Write-Host "[Chocolatey] âŒ Error: $($_.Exception.Message)"
            $published = "false"
            $e2e_result = "skipped"
            Set-Outputs -Published $published -E2E $e2e_result
            exit 1
          }

          Set-Outputs -Published $published -E2E $e2e_result

  scoop:
    needs: setup
    if: needs.setup.outputs.cache-hit != 'true'
    runs-on: windows-latest
    timeout-minutes: 15
    outputs:
      published: ${{ steps.scoop.outputs.published }}
      e2e: ${{ steps.scoop.outputs.e2e_result }}
    steps:
      - name: "ðŸ¦ Scoop Verify and Test (Extras bucket)"
        id: scoop
        shell: pwsh
        env:
          RELEASE_VERSION: ${{ needs.setup.outputs.release_version }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = "$env:RELEASE_VERSION"
          $bucket = "extras"
          $packageName = "winmemorycleaner"
          $qualified = "$bucket/$packageName"
          $e2e_result = "fail"
          $published = "false"

          function Set-Outputs {
            param($Published, $E2E)
            echo "published=$Published" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            echo "e2e_result=$E2E" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

          Write-Host "===[Scoop] Ensuring Scoop is installed==="
          try {
            if (-not (Get-Command scoop -ErrorAction SilentlyContinue)) {
              irm get.scoop.sh | iex
            }

            # Make sure the Extras bucket is present and up to date
            if (-not (scoop bucket list | Select-String -Pattern '^\s*extras(\s|$)' -Quiet)) {
              scoop bucket add $bucket
            }
            scoop bucket update $bucket

            # Robust version check: read the manifest JSON from the Extras bucket
            Write-Host "===[Scoop] Checking $qualified version $version==="
            $manifestRaw = ""
            try { $manifestRaw = scoop cat $qualified 2>$null | Out-String } catch {}
            if (-not $manifestRaw) {
              Write-Host "[Scoop] âŒ Manifest $qualified not found."
              $published = "false"
              $e2e_result = "skipped"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }

            try {
              $manifest = $manifestRaw | ConvertFrom-Json
            } catch {
              Write-Host "[Scoop] âŒ Failed to parse manifest JSON."
              $published = "false"
              $e2e_result = "skipped"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }

            $manifestVersion = "$($manifest.version)"
            Write-Host "[Scoop] Manifest version: $manifestVersion"
            if ($manifestVersion -eq $version) {
              Write-Host "[Scoop] âœ… Version found in '$bucket'."
              $published = "true"
            } else {
              Write-Host "[Scoop] âŒ Version mismatch in manifest. Expected $version, got $manifestVersion"
              $published = "false"
              $e2e_result = "skipped"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }

            Write-Host "[Scoop] Installing package from '$bucket'..."
            scoop install $qualified

            # After install, the local package name is unqualified
            $exe = "$(scoop prefix $packageName)\WinMemoryCleaner.exe"
            if (-not (Test-Path $exe)) {
              Write-Host "[Scoop] âŒ WinMemoryCleaner.exe not found after install"
              $e2e_result = "fail"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }

            $verInfo = (Get-Item $exe).VersionInfo
            $fileVersion = $verInfo.ProductVersion
            if ([string]::IsNullOrWhiteSpace($fileVersion)) { $fileVersion = $verInfo.FileVersion }
            $expectedRegex = '^' + [regex]::Escape($version) + '(\.0)?$'
            Write-Host "[Scoop] Installed file version: $fileVersion"
            if ($fileVersion -match $expectedRegex) {
              $e2e_result = "success"
              Write-Host "[Scoop] âœ… E2E Test successful (version matches)."
            } else {
              Write-Host "[Scoop] âŒ Version mismatch. Expected $version, got $fileVersion"
              $e2e_result = "fail"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }
          } catch {
            Write-Host "[Scoop] âŒ Error: $($_.Exception.Message)"
            $published = "false"
            $e2e_result = "skipped"
            Set-Outputs -Published $published -E2E $e2e_result
            exit 1
          }

          Set-Outputs -Published $published -E2E $e2e_result

  winget_cli:
    needs: setup
    if: needs.setup.outputs.cache-hit != 'true'
    runs-on: windows-latest
    continue-on-error: true
    timeout-minutes: 20
    outputs:
      found: ${{ steps.detect_winget.outputs.found }}
      published: ${{ steps.winget.outputs.published }}
      e2e: ${{ steps.winget.outputs.e2e_result }}
    steps:
      - name: "ðŸ”Ž Detect WinGet CLI & Version"
        id: detect_winget
        shell: pwsh
        run: |
          $found = 'false'
          $wingetPath = ''
          try {
            $wingetCmd = Get-Command winget -ErrorAction Stop
            $found = 'true'
            $wingetPath = $wingetCmd.Source
          } catch {
            $possiblePath = "$env:LOCALAPPDATA\Microsoft\WindowsApps\winget.exe"
            if (Test-Path $possiblePath) {
              $found = 'true'
              $wingetPath = $possiblePath
            }
          }
          Write-Host "===[WinGet] Found: $found"
          Write-Host "===[WinGet] Path: $wingetPath"
          echo "found=$found" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "path=$wingetPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: "ðŸ“¦ WinGet CLI Verify and Test"
        id: winget
        if: steps.detect_winget.outputs.found == 'true'
        shell: pwsh
        env:
          RELEASE_VERSION: ${{ needs.setup.outputs.release_version }}
        run: |
          $ErrorActionPreference = 'Stop'
          $expected = "$env:RELEASE_VERSION"
          $expectedRegex = '^' + [regex]::Escape($expected) + '(\.0)?$'
          $wingetExe = "${{ steps.detect_winget.outputs.path }}"
          if (-not (Test-Path $wingetExe)) { $wingetExe = "winget.exe" }
          $pkgName = "IgorMundstein.WinMemoryCleaner"
          $published = "false"
          $e2e_result = "fail"

          function Set-Outputs {
            param($Published, $E2E)
            echo "published=$Published" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            echo "e2e_result=$E2E" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

          Write-Host "===[WinGet] Using $wingetExe"
          try {
            Write-Host "[WinGet] Updating sources..."
            try { & $wingetExe source update } catch { Write-Host "[WinGet] source update failed (non-fatal)" }

            Write-Host "[WinGet] Checking available versions..."
            $versionsOut = & $wingetExe show --id $pkgName --source winget --versions --accept-source-agreements
            Write-Host "WinGet versions output:`n$versionsOut"

            $available = $versionsOut -split "`r?`n" |
              ForEach-Object { $_.Trim() } |
              Where-Object { $_ -match '^\d+(\.\d+){2,3}$' }

            if ($available | Where-Object { $_ -match $expectedRegex }) {
              Write-Host "[WinGet] âœ… Version $expected is listed."
              $published = "true"

              Write-Host "[WinGet] Installing exact version $expected..."
              & $wingetExe install --id $pkgName --version $expected --accept-source-agreements --accept-package-agreements --silent -o .

              $exePath = Join-Path (Get-Location) "WinMemoryCleaner.exe"
              if (-not (Test-Path $exePath)) {
                $cmd = Get-Command WinMemoryCleaner.exe -ErrorAction SilentlyContinue
                if ($cmd -and (Test-Path $cmd.Source)) { $exePath = $cmd.Source }
              }

              if (-not (Test-Path $exePath)) {
                Write-Host "[WinGet] âŒ WinMemoryCleaner.exe not found after install"
                $e2e_result = "fail"
                Set-Outputs -Published $published -E2E $e2e_result
                exit 1
              }

              $verInfo = (Get-Item $exePath).VersionInfo
              $fileVersion = $verInfo.ProductVersion
              if ([string]::IsNullOrWhiteSpace($fileVersion)) { $fileVersion = $verInfo.FileVersion }
              Write-Host "[WinGet] Installed file version: $fileVersion"
              if ($fileVersion -match $expectedRegex) {
                $e2e_result = "success"
                Write-Host "[WinGet] âœ… E2E Test successful (version matches)."
              } else {
                Write-Host "[WinGet] âŒ Version mismatch. Expected $expected, got $fileVersion"
                $e2e_result = "fail"
                Set-Outputs -Published $published -E2E $e2e_result
                exit 1
              }
            } else {
              Write-Host "[WinGet] âŒ Version $expected not yet in client index (likely ingestion delay)."
              $published = "false"
              $e2e_result = "skipped"
              Set-Outputs -Published $published -E2E $e2e_result
              exit 1
            }
          } catch {
            Write-Host "[WinGet] âŒ Error: $($_.Exception.Message)"
            $published = "false"
            $e2e_result = "skipped"
            Set-Outputs -Published $published -E2E $e2e_result
            exit 1
          }

          Set-Outputs -Published $published -E2E $e2e_result

  winget_manifest:
    needs: setup
    if: needs.setup.outputs.cache-hit != 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.check_manifest.outputs.published }}
      manifest_found: ${{ steps.check_manifest_url.outputs.manifest_found }}
    continue-on-error: true
    steps:
      - name: "ðŸŒ Check WinGet Manifest in winget-pkgs repo (API)"
        id: check_manifest
        shell: bash
        env:
          RELEASE_VERSION: ${{ needs.setup.outputs.release_version }}
        run: |
          file_path="manifests/i/IgorMundstein/WinMemoryCleaner/${RELEASE_VERSION}/IgorMundstein.WinMemoryCleaner.installer.yaml"
          url="https://api.github.com/repos/microsoft/winget-pkgs/contents/${file_path}"
          echo "Checking manifest existence: $url"
          if curl --fail -s "$url" > /dev/null; then
            echo "published=true" >> $GITHUB_OUTPUT
            echo "âœ… Published"
          else
            echo "published=false" >> $GITHUB_OUTPUT
            echo "âŒ Not Published"
          fi

      - name: "ðŸŒ Check WinGet Manifest in winget-pkgs repo (raw URL, non-blocking)"
        id: check_manifest_url
        shell: bash
        continue-on-error: true
        env:
          RELEASE_VERSION: ${{ needs.setup.outputs.release_version }}
        run: |
          file_path="manifests/i/IgorMundstein/WinMemoryCleaner/${RELEASE_VERSION}/IgorMundstein.WinMemoryCleaner.installer.yaml"
          manifest_url="https://raw.githubusercontent.com/microsoft/winget-pkgs/master/${file_path}"
          if curl --fail -s "$manifest_url" > /dev/null; then
            echo "manifest_found=true" >> $GITHUB_OUTPUT
            echo "âœ… Published"
          else
            echo "manifest_found=false" >> $GITHUB_OUTPUT
            echo "âŒ Not Published"
          fi

  summarize:
    needs: [setup, choco, scoop, winget_cli, winget_manifest]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: "ðŸ“ Publication Summary"
        run: |
          VERSION="${{ needs.setup.outputs.release_version }}"
          echo "### Publication Verification for $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "| Package Manager           | Publication Status      | E2 Test        |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------------------|------------------------|----------------|" >> $GITHUB_STEP_SUMMARY

          CH_PUB="${{ needs.choco.outputs.published }}"
          CH_E2E="${{ needs.choco.outputs.e2e }}"
          if [ "$CH_PUB" == "true" ]; then CH_STATUS="âœ… Published"; else CH_STATUS="âŒ Not Published"; fi
          if [ "$CH_E2E" == "success" ]; then CH_E2E_STATUS="âœ… Passed"; elif [ "$CH_PUB" == "true" ]; then CH_E2E_STATUS="âŒ Failed"; else CH_E2E_STATUS="âš ï¸ Skipped"; fi
          echo "| ðŸ« Chocolatey             | $CH_STATUS             | $CH_E2E_STATUS |" >> $GITHUB_STEP_SUMMARY

          SC_PUB="${{ needs.scoop.outputs.published }}"
          SC_E2E="${{ needs.scoop.outputs.e2e }}"
          if [ "$SC_PUB" == "true" ]; then SC_STATUS="âœ… Published"; else SC_STATUS="âŒ Not Published"; fi
          if [ "$SC_E2E" == "success" ]; then SC_E2E_STATUS="âœ… Passed"; elif [ "$SC_PUB" == "true" ]; then SC_E2E_STATUS="âŒ Failed"; else SC_E2E_STATUS="âš ï¸ Skipped"; fi
          echo "| ðŸ¦ Scoop (Extras)         | $SC_STATUS             | $SC_E2E_STATUS |" >> $GITHUB_STEP_SUMMARY

          WG_CLI_FOUND="${{ needs.winget_cli.outputs.found }}"
          WG_CLI_PUB="${{ needs.winget_cli.outputs.published }}"
          if [ "$WG_CLI_FOUND" == "true" ]; then
            if [ "$WG_CLI_PUB" == "true" ]; then WG_CLI_STATUS="âœ… Published"; else WG_CLI_STATUS="âŒ Not Published"; fi
            WG_CLI_E2E_RAW="${{ needs.winget_cli.outputs.e2e }}"
            if [ "$WG_CLI_E2E_RAW" == "success" ]; then WG_CLI_E2E_STATUS="âœ… Passed"
            elif [ "$WG_CLI_PUB" == "true" ]; then WG_CLI_E2E_STATUS="âŒ Failed"
            else WG_CLI_E2E_STATUS="âš ï¸ Skipped"; fi
          else
            WG_CLI_STATUS="âš ï¸ Not Installed"
            WG_CLI_E2E_STATUS="N/A"
          fi
          echo "| ðŸ“¦ WinGet CLI             | $WG_CLI_STATUS         | $WG_CLI_E2E_STATUS |" >> $GITHUB_STEP_SUMMARY

          WG_MANIFEST_PUB="${{ needs.winget_manifest.outputs.published }}"
          if [ "$WG_MANIFEST_PUB" == "true" ]; then
            WG_MANIFEST_STATUS="âœ… Published"
          else
            WG_MANIFEST_STATUS="âŒ Not Published"
          fi
          echo "| ðŸŒ WinGet Manifest (API)  | $WG_MANIFEST_STATUS    | N/A           |" >> $GITHUB_STEP_SUMMARY

          WG_MANIFEST_FOUND="${{ needs.winget_manifest.outputs.manifest_found }}"
          if [ "$WG_MANIFEST_FOUND" == "true" ]; then
            WG_MANIFEST_RAW_STATUS="âœ… Published"
          else
            WG_MANIFEST_RAW_STATUS="âŒ Not Published"
          fi
          echo "| ðŸŒ WinGet Manifest (RAW)  | $WG_MANIFEST_RAW_STATUS| N/A           |" >> $GITHUB_STEP_SUMMARY

          echo ""
          echo "_WinGet CLI test is authoritative; manifest checks are informational only._" >> $GITHUB_STEP_SUMMARY

      - name: "Set cache flag if all published"
        id: allpublished
        run: |
          ALL_PUBLISHED=true
          if [ "${{ needs.choco.outputs.published }}" != "true" ]; then ALL_PUBLISHED=false; fi
          if [ "${{ needs.scoop.outputs.published }}" != "true" ]; then ALL_PUBLISHED=false; fi
          if [ "${{ needs.winget_cli.outputs.published }}" != "true" ]; then ALL_PUBLISHED=false; fi
          if [ "${{ needs.winget_manifest.outputs.published }}" != "true" ]; then ALL_PUBLISHED=false; fi

          echo "ALL_PUBLISHED=$ALL_PUBLISHED" >> $GITHUB_ENV

          if [ "$ALL_PUBLISHED" = "true" ]; then
            mkdir -p .cache
            echo "all-published" > .cache/success.flag
            echo "All package managers published. Cache will be saved."
          else
            echo "Not all package managers published. Cache will NOT be saved."
          fi

      - name: "ðŸ’¾ Save Success Flag to Cache"
        if: env.ALL_PUBLISHED == 'true'
        uses: actions/cache/save@v4
        with:
          path: ./.cache
          key: ${{ needs.setup.outputs.cache-key }}
